;cons makes a flat merged array
;input bitmap
;represent as list of lists

((0 1 1 0 0 1 1 0)
 (1 1 0 0 1 0 1 1)
 (0 0 1 0 1 1 0 0))

; rectangular, square

;loop through bitmap element indices

;iterRow go through each row and call iterCol on it

;define an iterator
(_fillRows' ( (index' arraySoFar')
  (
    (
      (
        (index (bitmap len) eq?)
        (index arraySoFar cons)
      )
      (
        else
        ((index 1 -) (index arraySoFar cons) _fillRows)
      )
    )
  cond) lambda) define)
;(
;  iterRow
;  (
;  ()
;    (
;      (
;          ((rowNum' (bitmap' len) eq?) bitmap)
;          (else (row' (row 1 +) )
;      )
;      cond
;    )
;    lambda
;  )
  ;define
  ;)
;
;(
;  iterCol
;  (
;    (rowNum')
;    (
;
;    )
;    lambda
;  )
;  define
;)
;(colNum' (col 1 +) define) lambda


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bitmap ((0 1 1 0 0 1 1 0) (1 1 0 0 1 0 1 1) (0 0 1 0 1 1 0 0)) define)

;checkRules => takes the bitmap and loops through all the rules
(checkRules' ((rowIndex' colIndex') (rowIndex colIndex) lambda) define)
;define parseRow, which takes in a row index and generates all the column indices
(parseRow' ((rowIndex') (((((bitmap rowIndex get) len) 1 -) fillRange) ((colIndex) (rowIndex colIndex checkRules) lambda) map) lambda) define)
;map each row index to a list of column indices
((((bitmap len) 1 -) fillRange) ((rowIndex') (rowIndex parseRow) lambda) map)


# add language function that gets an element at an index

get count of live neighbors
access element of array that corresponds to correct rule
Number of Neighbors:
             0      1     2       3
liveList' = [dead', dead', live', live'] #if not in list, dead'
deadList' = [dead', dead', dead', live'] #if not in lisd, dead'
[dead', dead', live', ]

apply if it matches and exit loop
# subtract and add 1 in two dimensions
# implement getter from bitmap in lisp
# setter from bitmap in lisp
# length from bitmap in lisp => javascript
output new bitmap
